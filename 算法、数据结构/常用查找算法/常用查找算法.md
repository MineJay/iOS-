# 常用的查找算法

### 先了解一下查找算法的分类：

1. 静态查找和动态查找：	

	静态或者动态查找都是针对查找表而言的，如顺序查找、二分查找都是静态的。动态表指的是查找表中有插入或者删除操作的表，例如树表查找。
	
2. 无序查找和有序查找

	这个，都懂得。
	
	
## 一、顺序查找

#### 思路：
从数据结构线性表的一端开始，顺序扫描，依次将扫描到的节点的值与 给定值 K 作比较，若想等，则成功，若没有，则失败。
#### 复杂度：
时间复杂度 O(n)


	public static int orderSearch(int searchKey,int[] array){  
	    if(array==null||array.length<1)  
	        return -1;  
	    for(int i=0;i<array.length;i++){  
	        if(array[i]==searchKey){  
	            return i;  
	        }  
	    }  
	    return -1;     
	}



## 二、二分查找

#### 思路：
二分查找是有序查找，将给定的 K 值与中间节点的值作比较，由此分成两个子表，然后这样的递归进行查找。
#### 复杂度：
时间复杂度为 O(log2n)
#### 注意：
二分查找是对有序表进行查找，对于静态表，排序后不再改变，但是如果是动态表，不断进行插入或者删除，维持有序会带来不小的代价，所以不建议在动态表上用二分查找。


	public static int binarySearch(int[] array, int searchKey) {  
  
	    int low = 0;  
	    int high = array.length - 1;  
	    while (low <= high) {  
	        int middle = (low + high) / 2;  
	        if (searchKey == array[middle]) {  
	            return middle;  
	        } else if (searchKey < array[middle]) {  
	            high = middle - 1;  
	        } else {  
	            low = middle + 1;  
	        }  
	    }  
	    return -1;  
	}



## 三、分块查找

#### 思路：
分块查找又叫索引顺序查找，是顺序查找的一种改进。思想是：将 n 个数据元素分成 m 个块，在每一个块中的节点不必有序，但是块与块之间必须”按块有序“，即第一个块中的所有元素必须必第二块中的任意元素小，后面以此类推。然后建立一个索引表，把每块中的最大元素值按块的顺序放在辅助数组中，查找时，先用给定的关键字 K 值在索引表中查找，确定是哪个块，然后进入块进一步查找。


	public static int blockSearch(int[] index, int[] st, int key, int m) {  
	    // 在序列st数组中，用分块查找方法查找关键字为key的记录  
	    // 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中  
	    int i = binarySearch(index, key);  
	    if (i >= 0) {  
	        int j = i > 0 ? i * m : i;  
	        int len = (i + 1) * m;  
	        // 在确定的块中用顺序查找方法查找key  
	        for (int k = j; k < len; k++) {  
	            if (key == st[k]) {  
	                System.out.println("查询成功");  
	                return k;  
	            }  
	        }  
	    }  
	    System.out.println("查找失败");  
	    return -1;  
	}



## 四、树查找

### 二叉树查找

#### 思想：
先对待查找的数据生成二叉排序树，确保树的左分支的值小于右分支，然后查找，若 K 等于根节点，查找成功；小于根节点，则进入左子树查找，否则进入右子树。

### 红黑树

##### 思想：
可以看出，二叉查找树是一个很好的数据结构，可以很快的进行查找、插入、删除数据项等操作。但是，二叉查找树有一个很麻烦的问题，如果树中插入的数据是随机的，那么执行的效果很好，但是如果插入的值是有序的，那么二叉树就是非平衡的了，会排在一条线上，就像一个链表，那么它的快速查找、插入、删除数据项的能力就丧失了。

#### 红黑树特征：
它主要有两个特征：1.节点都有颜色。2.再插入和删除的过程中，要遵循保持这些颜色的不同排列规则。第一点好理解，第二点的规则有以下几点：

1.	每个节点不是红色就是黑色
2. 根节点总是黑色的
3. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
4. 从根节点到叶节点或者空节点的每条路径，必须包含相同数目的黑色节点（即相同的而黑色高度）


#### 红黑树的操作：
1.	变色
2. 左旋
3. 右旋























